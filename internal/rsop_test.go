package internal

import (
	"testing"

	"github.com/google/go-cmp/cmp"
)

func TestRSoP(t *testing.T) {
	t.Parallel()
	t.Run("Single", func(t *testing.T) {
		t.Parallel()
		testRSoPResult(t,
			[]*Policy{
				{
					Name: "basic", Paths: []PathConfig{
						{
							Path:         "test/basic",
							Capabilities: []Capability{Create, Update},
						},
					},
				},
			},
			map[string]map[Capability][]string{
				"test/basic": {
					Create: {"basic"},
					Update: {"basic"},
				},
			},
		)
	})
	t.Run("Merge", func(t *testing.T) {
		t.Parallel()
		testRSoPResult(t,
			[]*Policy{
				{
					Name: "first",
					Paths: []PathConfig{
						{
							Path: "some/path/+/here",
							Capabilities: []Capability{
								Create,
								Update,
							},
						},
					},
				},
				{
					Name: "second",
					Paths: []PathConfig{
						{
							Path: "some/path/+/here",
							Capabilities: []Capability{
								Create,
								Update,
								Delete,
								List,
							},
						},
					},
				},
			},
			map[string]map[Capability][]string{
				"some/path/+/here": {
					Create: {"first", "second"},
					Delete: {"second"},
					List:   {"second"},
					Update: {"first", "second"},
				},
			},
		)
	})
}

// tests that HCL emission is stable and nicely formatted
func TestRSoPHCL(t *testing.T) {
	t.Parallel()
	var (
		r = &RSoP{Policies: []*Policy{
			{
				Name: "simple",
				Paths: []PathConfig{
					{
						Path:         "test/simple",
						Capabilities: []Capability{Read},
					},
					{
						Path:         "test/simple/multiple",
						Capabilities: []Capability{Create, Read},
					},
					{
						Path:         "multi-*",
						Capabilities: []Capability{Create, Read},
					},
				},
			},
			{
				Name: "multi",
				Paths: []PathConfig{
					{
						Path:         "multi-*",
						Capabilities: []Capability{Create, Delete},
					},
				},
			},
		}}
		expected = `# generated by hvresult

path "multi-*" {
  capabilities = [
    "create", # from: simple, multi
    "delete", # from: multi
    "read",   # from: simple
  ]
}

path "test/simple" {
  capabilities = [
    "read", # from: simple
  ]
}

path "test/simple/multiple" {
  capabilities = [
    "create", # from: simple
    "read",   # from: simple
  ]
}
`
	)
	// so there's no question about whether it generated correctly
	capmap := r.GetCapabilityMap()
	expectedCapmap := RSoPCapMap(map[string]map[Capability][]string{
		"test/simple": {
			Read: {"simple"},
		},
		"test/simple/multiple": {
			Create: {"simple"},
			Read:   {"simple"},
		},
		"multi-*": {
			Create: {"simple", "multi"},
			Read:   {"simple"},
			Delete: {"multi"},
		},
	})
	if diff := cmp.Diff(expectedCapmap, capmap); diff != "" {
		t.Fatal(diff)
	}
	hcl := capmap.HCL()
	if diff := cmp.Diff(expected, hcl); diff != "" {
		// the diff can be a mess sometimes
		t.Logf("got: %s", hcl)
		t.Fatal(diff)
	}
}

func testRSoPResult(t *testing.T, policies []*Policy, expected map[string]map[Capability][]string) {
	t.Helper()
	r := &RSoP{Policies: policies}
	capmap := r.GetCapabilityMap()
	if diff := cmp.Diff(RSoPCapMap(expected), capmap); diff != "" {
		t.Fatal(diff)
	}
}
